import tensorflow as tf
from sklearn.model_selection import train_test_split
import numpy as np
from sklearn.preprocessing import StandardScaler

import load_data

# Define the model
model = tf.keras.models.Sequential([
    # tf.keras.layers.Reshape((90, 90, 1), input_shape=(90, 90)),

    tf.keras.layers.Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(90, 90, 1)),
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])


# Compile the model
model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

# import load_data.py and use load_malware_images() and load_benign_images() to load the data
malware_images = tf.convert_to_tensor(load_data.load_malware_images())
benign_images = tf.convert_to_tensor(load_data.load_benign_images())

# Reshape the tensors to have 2 dimensions
malware_images_2d = tf.reshape(malware_images, (malware_images.shape[0], -1))
benign_images_2d = tf.reshape(benign_images, (benign_images.shape[0], -1))

# Convert tensors to numpy arrays for scaling
malware_images_2d_np = malware_images_2d.numpy()
benign_images_2d_np = benign_images_2d.numpy()

# Apply the StandardScaler
scaler = StandardScaler()
malware_images_scaled = scaler.fit_transform(malware_images_2d_np)
benign_images_scaled = scaler.fit_transform(benign_images_2d_np)

# Convert back to tensors
malware_images_scaled_2d = tf.convert_to_tensor(malware_images_scaled)
benign_images_scaled_2d = tf.convert_to_tensor(benign_images_scaled)

# Reshape the scaled tensors back to the original 3D shape
malware_images_scaled_3d = tf.reshape(malware_images_scaled_2d, malware_images.shape)
benign_images_scaled_3d = tf.reshape(benign_images_scaled_2d, benign_images.shape)

# reshape this data to 90X90
malware_images_scaled_3d = tf.reshape(malware_images_scaled_3d, (malware_images_scaled_3d.shape[0], 90, 90, 1))
benign_images_scaled_3d = tf.reshape(benign_images_scaled_3d, (benign_images_scaled_3d.shape[0], 90, 90, 1))

# Combine images and labels
# x = np.concatenate((malware_images, benign_images), axis=0)
# y = np.concatenate((np.ones(len(malware_images)), np.zeros(len(benign_images))))

x = np.concatenate((malware_images_scaled_3d, benign_images_scaled_3d), axis=0)
y = np.concatenate((np.ones(len(malware_images_scaled_3d)), np.zeros(len(benign_images_scaled_3d))))

# Shuffle data
shuffle_idx = np.random.permutation(len(x))
x = x[shuffle_idx]
y = y[shuffle_idx]

# Split data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)

# Train the model
# model.fit(x_train, y_train, epochs=10, batch_size=32, validation_data=(x_test, y_test))
model.fit(x_train, y_train, epochs=1, batch_size=32, validation_data=(x_test, y_test))

# Evaluate the model
print("Evaluate on test data")
print(model.evaluate(x_test, y_test))

# Accuracy_score
from sklearn.metrics import accuracy_score

y_pred = model.predict(x_test)
y_pred = np.round(y_pred)
print("Accuracy score: ")
print(accuracy_score(y_test, y_pred))

from sklearn.metrics import confusion_matrix

# Specificity_score
print("Specificity score: ")
tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
print(tn / (tn + fp))

# Sensitivity_score
print("Sensitivity score: ")
print(tp / (tp + fn))

# Precision_score
from sklearn.metrics import precision_score

print("Precision score: ")
print(precision_score(y_test, y_pred, zero_division=1))

# Recall_score
from sklearn.metrics import recall_score

print("Recall score: ")
print(recall_score(y_test, y_pred))
# F1_score
from sklearn.metrics import f1_score

print("F1 score: ")
print(f1_score(y_test, y_pred, zero_division=1))

# Confusion_matrix
print("Confusion matrix: ")
print(confusion_matrix(y_test, y_pred))

# #Classification_report
# from sklearn.metrics import classification_report
# print("Classification report: ")
# print(classification_report(y_test, y_pred))

import pandas as pd
from sklearn.metrics import classification_report

# Assuming you have your true labels in y_true and predicted labels in y_pred

# Generate the classification report
report = classification_report(y_test, y_pred, output_dict=True)

# Convert the report to a DataFrame
df_report = pd.DataFrame(report).transpose()

# Print the classification report in table format
print("Classification Report:")
print(df_report)

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix

# Example confusion matrix
labels = ['Benign', 'Malware']
cm = [[442, 0],
      [22, 44]]

# Create a dataframe from the confusion matrix
df_cm = pd.DataFrame(cm, index=labels, columns=labels)

# Set the figure size
plt.figure(figsize=(6, 4))

# Plot the confusion matrix heatmap
sns.heatmap(df_cm, annot=True, fmt='d', cmap='Blues')

# Set labels, title, and axis ticks
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')

# Display the confusion matrix
plt.show()
